package api {
  class Injector {
    -providers: Hash<String, Provider>
    +register(name: String, provider: Provider)
    +has(name: String): Boolean
    +get(name: String): Provider
    +invoke(function: Function): Object
  }
  note left of Injector
    Providers:
    $input: Dictionary<string,TValue>
    $output: Dictionary<string,TValue>
    $options: Dictionary<string,TValue>
    $connections: Connection
    $lastOutput: Dictionary<string,TValue> 
    $lastInput: Dictionary<string,TValue>
    $source: ConnectableNode
    $destination: ConnectableNode
  end note

  class Blueprint {
    -injector: Injector
    +sender(name, definition)
    +receiver(name, definition)
    +processor(name, definition)
    +module(name, definition)
    +connection(name, definition)
    +constant(name, value)
  }

  note top of Blueprint
    blueprint.sender(name, definition):
      injector.register(name, ($a, $b, $c) ->
        var Class = Sender.extend(definition);
        return getValue: () -> Class;
      )
  end note

  Blueprint o-- Injector
  Injector o-- Provider

  class Provider {
    +getValue(): object
  }
  
  class Type {
    +validator: Func<object, boolean>
  }
  
  class Parameter {
    +name: string
    +type: Type
    +default: object
  }
  Parameter o-- Type
}

package basics { 
  interface EventEmitter {
    +on(eventName, callback)
    +trigger(eventName, arguments)
  }

  abstract class Node {
    +parent: ModuleInstance
  }
  EventEmitter <|-- Node
  
  package connectables {
    abstract class ConnectableNode {
      +id: Int
      +options: Parameter[]
      +type: NeuronType
      +incomingConnections: Connection[]
      +outgoingConnections: Connection[]
      +connectAsSender(connection: Connection)
      +connectAsReceiver(connection: Connection)
    }
    Node <|-- ConnectableNode

    abstract class Sender {
      +output: Type[]
      +compute: InjectableFunction<float>
    }
    ConnectableNode <|-- Sender
    note bottom of Sender
      connectAsReceiver(connection):
        throw new Error();
    end note

    abstract class Receiver {
      +input: Parameter[]
      +compute: InjectableFunction<void>
    }
    ConnectableNode <|-- Receiver
    note bottom of Receiver
      connectAsSender(connection):
        throw new Error();
    end note

    abstract class Processor {
      +input: Parameter[]
      +output: Parameter[]
      +compute: InjectableFunction<float>
    }
    ConnectableNode <|-- Processor

    abstract class Connection {
      +source: ConnectableNode
      +destination: ConnectableNode
      +compute: InjectableFunction<float>
    }
    EventEmitter <|-- Connection
    ConnectableNode --o Connection
  }
  
  package composites {
    class Group {
      +nodes: Node[]
    }
    Node <|-- Group
    Node --o Group
    
    class Module {
      +build(options, self: ModuleInstance)
    }

    class ModuleBuilder {
      -result: ModuleInstance
      -finished: boolean
      +add(node: Node)
      +group(nodes: Node[])
      +connect(source: Node, destination: Node, options)
      +end()
      +getResult(): ModuleInstance
      +register(name: String, node: Node)
      +setSender(node: Node)
      +setReceiver(node: Node)
    }
    ModuleInstance <-- ModuleBuilder : produces 
    ModuleInstance <-- Module : defines
    ModuleBuilder <-- Module : new/uses

    class ModuleInstance {
      +nodes: Node[]
      +connections: Connection[]
    }
    Node <|-- ModuleInstance
    ModuleInstance o-- Node
    ModuleInstance o-- Connection
  }
}
/'
package processors {
  class Neuron {
    +threshold: float
    +factor: float
    +maximum: float
    +associateConstant: float
    +disassociateConstant: float
  }
  Processor <|-- Neuron
}

package senders {
  class Switch {
  
  }
  Sender <|-- Switch
  
  class Slider {
  
  }
  Sender <|-- Slider
  
  class Random {

  }
  Sender <|-- Random
}

package receivers {
  class LED {
    
  }
  Receiver <|-- LED
  
  class Gauge {
    
  }
  Receiver <|-- Gauge

  class Plot {
    
  }
  Receiver <|-- Plot
}

package modules {
  class Image {
    +width: Int
    +height: Int
  }
  ModuleInstance <-- Image
  ModuleInstance <-- IfThenElse
  ModuleInstance <-- While
  ModuleInstance <-- Do
  ModuleInstance <-- Select
}'/